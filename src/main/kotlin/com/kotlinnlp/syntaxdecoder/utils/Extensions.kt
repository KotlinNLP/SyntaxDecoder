/* Copyright 2017-present The KotlinNLP Authors. All Rights Reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * ------------------------------------------------------------------*/

package com.kotlinnlp.syntaxdecoder.utils

import com.kotlinnlp.syntaxdecoder.transitionsystem.Transition
import com.kotlinnlp.syntaxdecoder.transitionsystem.state.State

/**
 * A [Comparator] of actions by score and then by transition priority.
 */
private val scoreTransitionComparator
  = compareByDescending<Transition<*, *>.Action> { it.score }.thenBy { it.transition.priority }

/**
 * Sort a list of actions by descending score and then by transition priority.
 */
fun <TransitionType: Transition<TransitionType, StateType>, StateType: State<StateType>>
  List<Transition<TransitionType, StateType>.Action>.sortByScoreAndPriority()
  = this.sortedWith(scoreTransitionComparator)

/**
 * @return a map of transitions to the actions generated by each of them
 */
fun <TransitionType: Transition<TransitionType, StateType>, StateType: State<StateType>>
  List<Transition<TransitionType, StateType>.Action>.groupByTransitions():
  Map<TransitionType, List<Transition<TransitionType, StateType>.Action>>
  = this.groupBy { it.transition }

/**
 * @return the list of unique transitions that generated this actions
 */
fun <TransitionType: Transition<TransitionType, StateType>, StateType: State<StateType>>
  List<Transition<TransitionType, StateType>.Action>.toTransitions(): List<TransitionType>
  = this.groupByTransitions().keys.toList()

/**
 * @return a map of transition ids to the related transitions that generated this actions
 */
fun <TransitionType: Transition<TransitionType, StateType>, StateType: State<StateType>>
  List<Transition<TransitionType, StateType>.Action>.toTransitionsMap(): Map<Int, TransitionType>
  = this.toTransitions().associateBy { it.id }

/**
 * @return a randomly selected action
 */
fun <TransitionType: Transition<TransitionType, StateType>, StateType: State<StateType>>
  List<Transition<TransitionType, StateType>.Action>.getRandom():
  Transition<TransitionType, StateType>.Action
  = this[Math.round(Math.random() * this.lastIndex).toInt()]

/**
 * Remove the last element
 */
fun <E>MutableList<E>.removeLast() {
  this.removeAt(this.lastIndex)
}

/**
 *
 */
fun <E>MutableList<E>.removeFrom(index: Int): MutableList<E> {
  this.subList(index, this.size).clear()
  return this
}

/**
 * Returns a list containing elements at indices in the specified [indices] range removing them from the origin.
 */
fun <E>MutableList<E>.extractAndRemove(indices: IntRange): List<E> {
  val elements = this.slice(indices)
  indices.reversed().forEach { this.removeAt(it) }
  return elements
}

/**
 *
 */
fun <E>MutableList<E>.subListFrom(fromIndex: Int): MutableList<E>? =
  if (fromIndex > this.lastIndex){
    null
  } else {
    this.subList(fromIndex, this.lastIndex)
  }

/**
 * @return the last element removing it
 */
fun <E>MutableList<E>.pop(): E {
  val element = this.last()
  this.removeAt(this.lastIndex)
  return element
}

/**
 * removes the first element from an items and returns that element.
 * This method changes the length of the items.
 */
fun <E>MutableList<E>.removeFirst(): E {
  val element = this.first()
  this.removeAt(0)
  return element
}

/**
 * @return the second to last element
 */
fun <E>MutableList<E>.secondToLast(): E = this[this.lastIndex - 1]

/**
 * @param  index gets the nth element
 *         -index gets the nth-to-last element
 * @return the element at the given index or null if the index is not in the array range
 */
fun <E>MutableList<E>.getItemOrNull(index: Int): E? {
  val accessIndex = if (index < 0) this.size + index else index
  return if (accessIndex in 0..this.lastIndex) this[accessIndex] else null
}

/**
 * Group a list of elements into groups of elements. 10 -> 4
 *
 * @param groupSize the max number of elements in a group
 *
 * @return a list of elements groups (lists of elements)
 */
fun <T: Any?> List<T>.groupBySize(groupSize: Int): List<List<T>> {

  var tIndex = 0
  val remainder = this.size % groupSize
  val nGroups: Int = this.size / groupSize + (if (remainder == 0) 0 else 1)

  return this.groupBy { tIndex++ % nGroups }.values.toList()
}
